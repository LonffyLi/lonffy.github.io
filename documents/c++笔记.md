#### 模板类中函数

```
问题描述
    习惯性的将函数的定义和实现，分别写在头文件和源文件（.cpp）中。今天也按照这个习惯实现了一个模板函数。然后编译时报错
... error: undefined reference to ...

原因分析
    c++中模板的声明和定义不能分开。C++中每一个对象所占用的空间大小，是在编译的时候就确定的，在模板类没有真正的被使用之前，编译器是无法知道，模板类中使用模板类型的对象的所占用的空间的大小的。只有模板被真正使用的时候，编译器才知道，模板套用的是什么类型，应该分配多少空间。这也就是模板类为什么只是称之为模板，而不是泛型的缘故。
所以说，模板函数的定义和声明要放在同一个.h文件中，如果分成.h和.cpp来放，会链接失败
```

#### const 修饰的变量理解

```
涉及到指针的情况：
int b=100;
const int * a=&b [1];
int const *a=&b; [2]
int* const a=&b; [3]
const int* const a =&b; [4]
如果const位于星号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。因此，[1]和[2]的情况相同，都是指针所指向的内容为常量（const放在变量声明符的位置无关），这种情况下不允许对内容进行更改操作，如不能*a = 3 ；[3]为指针本身是常量，而指针所指向的内容不是常量，这种情况下不能对指针本身进行更改操作，如a++是错误的；[4]为指针本身和指向的内容均为常量。
```

#### C++ 构造函数后加冒号

```
    其实冒号后的内容是初始化成员列表，一般有三种情况：
    1、对含有对象成员的对象进行初始化，例如，
    类line有两个私有对象成员startpoint、endpoint,line的构造函数写成：
    line（int sx,int sy,int ex,int ey）：startpoint（sx,sy），endpoint（ex,ey）{……}
    初始化时按照类定义中对象成员的顺序分别调用各自对象的构造函数，再执行自己的构造函数
    2、对于不含对象成员的对象，初始化时也可以套用上面的格式，例如，
    类rectangle有两个数据成员length、width,其构造函数写成：
    rectangle（）：length（1），width（2）{}
    rectangle（int x,int y）：length（x），width（y）{}
    3、对父类进行初始化，例如，
    CDlgCalcDlg的父类是MFC类CDialog,其构造函数写为：
    CDlgCalcDlg（CWnd* pParent ）： CDialog（CDlgCalcDlg::IDD, pParent）
    其中IDD是一个枚举元素，标志对话框模板的ID
    使用初始化成员列表对对象进行初始化，有时是必须的，有时是出于提高效率的考虑
```
